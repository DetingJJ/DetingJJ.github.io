if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m02']=[{"name":"01-开源协议-零度.md","path":"02-计算机基础/01-开源协议-零度.md","content":"## 开源协议介绍 -零度  \r\n\r\n如今的开源社区越来越热闹，所谓开源，就是开放软件的实现源码，为了保护作者许可内的著作权，给以他们法律层面的保护，建立许可协议将非常重要，各种乱七八糟的开源协议有时会让人您眼花缭乱，下面零度就为您做个简单的比较，关于细枝末节您可以访问百科查阅。\r\n\r\n![](assets/02/01-1524798113000.png)\r\n\r\n上面的图为零度原创，为了说明开源协议区别，复制请注明出处，目前微软.NET就是基于MIT许可证协议开源的。\r\n\r\n### BSD许可证协议\r\n\r\nBSD是一种非常自由的开源协议，你可以针对源码进行二次开发，将修改后的源码你可以选择免费，也可用于商业用途。但它的有几个小要求：除你自己二次开发的部分外，原本代码必须使用BSD许可证协议继续分发，这也就是说，你修改的部分可以随便遵守某种其它开源协议，但原本部分必须继续遵守BSD许可证协议。由于BSD允许你修改后重新商用，所以对于盈利性企业来说是个友好的协议。\r\n\r\n### Apache许可证协议\r\n\r\nApache协议与BSD协议很类似，同样可用于免费和商业之处，不同与BSD的是Apache要求在新增文件和修改过的文件中进行注释，并保留原始版权。\r\n\r\n### GPL许可证协议\r\n\r\nGPL协议允许您使用源码，修改源码，可二次分发，但使用和二次分发的的前提是你也必须也使用GPL协议，这意味着如果项目中引用GPL协议的代码，你的整个软件业必须遵守GPL协议，不能用于商业用途，这对盈利性企业是不友好的，因为你用了免费，你也得全部免费，鼓励传播，Linux的开源就基于GPL协议，商业软件不得使用GPL协议开源的代码，这强制要求你修改后也必须开源。\r\n\r\n### LGPL许可证协议\r\n\r\nLGPL协议开源的代码，可以使用和修改，但二次分发中原本代码必须继续使用LGPL协议，原创部分可不作此限制，与GPL不同的是LGPL可以用于商业软件。\r\n\r\n### MPL许可证协议\r\n\r\nMPL是Mozilla Public License的简称，修改后的不得将版权变更为修改者，版权归原始发起作者所有，可以在商业软件中使用。\r\n\r\n### MIT许可证协议\r\n\r\nMiT协议和BSD协议一样自由，作者只想保留版权，无其它任何限制，你不能修改或者移除代码中的版权申明，但你可以使用和修改源码，可免费二次分发，也可用于商业用途的分发，商业软件可以使用，微软.NET目前开源就是采用MIT协议，这是一种比较自由的开源协议。","timestamp":1524809995335},{"name":"02-堆栈的区别.md","path":"02-计算机基础/02-堆栈的区别.md","content":"## 堆栈的区别  \r\n堆的理解:  \r\n  堆是一大堆不连续的内存区域,在系统中由列表将他们串接起来,为了数据隐蔽,堆中的每个单元内存都是匿名的,因此你必须先在堆中申请一个内存单元地址,然后把他保存在一个指针中,这样你只有使用指针才可以访问到该内存单元的内容.  \r\n堆的好处:  \r\n 1. 可以存储比较大的数据  \r\n 2. 程序员自己控制创建和释放  \r\n 3. 只有特定的指针才能访问特定的数据,这样就避免了任何试图修改他的操作  \r\n做法:\r\n    首先创建一个堆,然后定义一个指向该堆的指针,这样就只能通过该指针才能访问堆中的数据  C++中使用关键字new创建一个堆并分配一个内存,在new  后面跟一个要分配的对象类型,便宜器根据这个类型来确定分配内存的大小  \r\n    int *p;//定义了一个指向整型的指针变量p  \r\n    p=new int;//new来在堆中创建一个int类型的内存区域,然后将该区域的内存指针赋值给指针变量 p,这样的话p所指向的就是这块新建立的内存区域    \r\n    new int //创建成功了返回一个地址 把这个地址赋给p  \r\n    也可以合并为一句话int *p=new int;  \r\n    这样的话定义指针p的同时初始化了他的值为一个在堆中新建的int型的存储区的内存地址  \r\n    我们可以像使用普通指针一样使用他并且把值赋给他所指向的内存空间  \r\n    *p=1;   \r\n注意由于内存很有限所以可能会出现没有足够内存而无法满足new请求的情况,在这种情况下,new会返回0,该值被赋值给指针后该指针就是一个空指针,空指针不会指向有效数据.   \r\n注意指针的内存泄露:  \r\n内存泄露:由于使用new创建的内存空间不会被系统自动释放,因此假如你不去释放他那么该区域的内存将始终不能为其他数据所使用,而指向该内存的指针是个局部变量,当定义该指针的函数结束并返回的时候,指针也就消失了,那么我们就再也找不到该块内存区域了,这种情况我们叫内存泄露,因此假如你不需要一块内存空间 那么就必须对指向他的指针使用关键字delete  \r\nint *p=new int; delete p;这样的话将释放指针所指向的内存,而不会释放指针,因此你还可以使用这个指针而先前指针指向的堆中的内存已经释放了  \r\n注意 如果指针指向了堆中对象的话只能释放一次不能重复释放,要释放指针的话将p=0;这样的话 释放一个空指针是可以的  \r\n程序如下:  \r\n```C++\r\nint *p=new int;//向系统申请一块int类型的堆中的内存把返回的地址赋给int 类型的指针p\r\ndelete p;//删除了指针p所指向的那块内存但是指针还保留着\r\np=new int;//再申请一块堆中内存把返回的地址赋值给指针p\r\ndelete p;//再删除指针所指向的那块内存\r\np=0;//设置指针为空指针\r\ndelete p;//删除指针 如果没有上面的设置为空指针那么俩个delete p是错误的\r\nreturn 0;\r\n```\r\n内存泄露的小代码:   \r\n```C++\r\nint *p=new int;\r\np=new int;\r\n```\r\n正确的做法:  \r\n```C++\r\nin*p=new int;\r\ndelete p;\r\np=new int;\r\n```\r\n或者  \r\n```C++\r\nin*p1=new int;\r\nin*p2=new int;\r\n```\r\n//堆代码解释\r\nHuman *p;//定义了一个Human类的指针\r\np=new Human;//创建了一块内存区域,同时调用Human类的默认构造方法来构造一个对象,它所占用的内存大小根据Human对象的成员变量来决定,假如该类有俩个int类型的成员变量.那么该对象占用2*4=8个字节,本行的右半部分创建一个对象完毕后,跟着将该内存地址赋值给左边的指针变量p.\r\n上面俩行可以合并 Human *p=new Human;\r\ndelete p;//调用对象的析构函数 并释放内存\r\n\r\n堆和栈的区别                               \r\n一般认为在c中分为这几个存储区  \r\n1. 栈 - 由编译器自动分配释放\r\n2. 堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收\r\n3. 全局区（静态区），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静\r\n态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。\r\n - 程序结束释放\r\n4. 另外还有一个专门放常量的地方。 - 程序结束释放\r\n在函数体中定义的变量通常是在栈上，用malloc, calloc, realloc等分配内存的函数分\r\n配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪\r\n里都存放在全局区（静态区）,在所有函数体外定义的static变量表示在该文件中有效，\r\n不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，\r\n函数中的\"adgfdf\"这样的字符串存放在常量区。\r\n比如：\r\nint a = 0; 全局初始化区\r\nchar *p1; 全局未初始化区\r\nmain()\r\n{\r\nint b; 栈\r\nchar s[] = \"abc\";栈\r\nchar *p2; 栈\r\nchar *p3 = \"123456\"; 123456\\0在常量区，p3在栈上。\r\nstatic int c =0； 全局（静态）初始化区\r\np1 = (char *)malloc(10);\r\np2 = (char *)malloc(20);\r\n分配得来得10和20字节的区域就在堆区。\r\nstrcpy(p1, \"123456\"); 123456\\0放在常量区，编译器可能会将它与p3所指向的\"12345\r\n6\"优化成一块。\r\n}\r\n还有就是函数调用时会在栈上有一系列的保留现场及传递参数的操作。  \r\n栈的空间大小有限定，vc的缺省是2M。栈不够用的情况一般是程序中分配了大量数组和递归函数层次太深。有一点必须知道，当一个函数调用完返回后它会释放该函数中所有的栈空间。栈是由编译器自动管理的，不用你操心。\r\n堆是动态分配内存的，并且你可以分配使用很大的内存。但是用不好会产生内存泄漏。并且频繁地malloc和free会产生内存碎片（有点类似磁盘碎片），因为c分配动态内存时是寻找匹配的内存的。而用栈则不会产生碎片。在栈上存取数据比通过指针在堆上存取数据快些。\r\n一般大家说的堆栈和栈是一样的，就是栈(stack)，而说堆时才是堆heap.栈是先入后出的，一般是由高地址向低地址生长。\r\n堆(heap)和栈(stack)是C/C++编程不可避免会碰到的两个基本概念。首先，这两个概念都可以在讲数据结构的书中找到，他们都是基本的数据结构，虽然栈更为简单一些。在具体的C/C++编程框架中，这两个概念并不是并行的。对底层机器代码的研究可以揭示，栈是机器系统提供的数据结构，而堆则是C/C++函数库提供的。  \r\n具体地说，现代计算机(串行执行机制)，都直接在代码底层支持栈的数据结构。这体现在，有专门的寄存器指向栈所在的地址，有专门的机器指令完成数据入栈出栈的操作。这种机制的特点是效率高，支持的数据有限，一般是整数，指针，浮点数等系统直接支持的数据类型，并不直接支持其他的数据结构。因为栈的这种特点，对栈的使用在程序中是非常频繁的。对子程序的调用就是直接利用栈完成的。机器的call指令里隐含了把返回地址推入栈，然后跳转至子程序地址的操作，而子程序中的ret指令则隐含从堆栈中弹出返回地址并跳转之的操作。C/C++中的自动变量是直接利用栈的例子，这也就是为什么当函数返回时，该函数的自动变量自动失效的原因(因为 颜换指戳说饔们暗 状态)。  \r\n和栈不同，堆的数据结构并不是由系统(无论是机器系统还是操作系统)支持的，而是由函数库提供的。基本的malloc/realloc/free函数维护了一套内部的堆数据结构。当程序使用这些函数去获得新的内存空间时，这套函数首先试图从内部堆中寻找可用的内存空间，如果没有可以使用的内存空间，则试图利用系统调用来动态增加程序数据段的内存大小，新分配得到的空间首先被组织进内部堆中去，然后再以适当的形式返回给调用者。当程序释放分配的内存空间时，这片内存空间被返回内部堆结构中，可能会被适当的处理(比如和其他空闲空间合并成更大的空闲空间)，以更适合下一次内存分配申请。这套复杂的分配机制实际上相当于一个内存分配的缓冲池(Cache)，使用这套机制有如下若干原因：\r\n1. 系统调用可能不支持任意大小的内存分配。有些系统的系统调用只支持固定大小及其倍数的内存请求(按页分配)；这样的话对于大量的小内存分类来说会造成浪费。  \r\n2. 系统调用申请内存可能是代价昂贵的。系统调用可能涉及用户态和核心态的转换。  \r\n3. 没有管理的内存分配在大量复杂内存的分配释放操作下很容易造成内存碎片。  \r\n堆和栈的对比  \r\n从以上知识可知，栈是系统提供的功能，特点是快速高效，缺点是有限制，数据不灵活；而栈是函数库提供的功能，特点是灵活方便，数据适应面广泛，但是效率有一定降低。栈是系统数据结构，对于进程/线程是唯一的；堆是函数库内部数据结构，不一定唯一。不同堆分配的内存无法互相操作。栈空间分静态分配和动态分配两种。静态分配是编译器完成的，比如自动变量(auto)的分配。动态分配由alloca函数完成。栈的动态分配无需释放(是自动的)，也就没有释放函数。为可移植的程序起见，栈的动态分配操作是不被鼓励的！堆空间的分配总是动态的，虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存/释放内存匹配是良好程序的基本要素。\r\n可以放一块思考\r\n堆和栈的生长方向恰好相反，  \r\n![](assets/02/02-1524807749000.png)\r\n所以计算机中的堆和栈经常时放一块讲的  \r\nnod 一般不是必要就不要动态创建，最讨厌把new出来的东西当局部变量用，用完了马上delete 的做法.  \r\n理由  \r\n1. 栈分配比堆快，只需要一条指令就能给配所有的局部变量  \r\n2. 栈不会出现内存碎片  \r\n3. 栈对象好管理  \r\n\r\n当然，某些情况下也要那么写,比如  \r\n1. 对象很大\r\n2. 对象需要在某个特定的时刻构造或析够\r\n3. 类只允许对象动态创建,比如VCL的大多数类  \r\n当然，必须用堆对象时也不能躲避  ","timestamp":1524809995335}]