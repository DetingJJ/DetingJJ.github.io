if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m03']=[{"name":"01-MarshalAs.md","path":"03-程序语言开发/01-C++/01-MarshalAs.md","content":"## MarshalAs  \r\nMarshalAs是提供向非托管代码封送数据时的规则。比如String或StringBuilder型，传递给非托管代码的时候可能是LPStr LPWStr BStr等等。你通过MarshalAs特性告诉.NET应该封送成什么类型。  \r\nMarshal就是把一个结构（类）序列化成一段内存，然后送到另一个进程（.net中Application domain)中供另一个进程中的函数使用。  \r\n比如你的一个结构   \r\n```C++ \r\nstruct\r\n{  \r\nPen pen;  \r\n }s; \r\n```\r\ns是一个指向已有的Pen对象的引用，当你把s传给本进程中的一个函数f时,f可以很容易地找到pen的实际对象，但如果你把s传到另外一个进程时，甚至是另外一台机器上的进程时，这个进程就没办法找到pen的实际内容。Marshal技术则可以把pen对象中的所有实际内容按规则放到一个缓冲中，（所有的引用或指针都要转换成实际对象）然后把缓冲中的内容送到另一个进程，函数调用完成再用同样方式把结果返回来。在RPC,Interop,COM中Marshal应用很多。\r\n```C++\r\n[StructLayout(LayoutKind.Sequential)] \r\npublic   struct   DVSNET_EMAIL_PARAM \r\n{ \r\n        [MarshalAs(UnmanagedType.ByValArray,   SizeConst   =   64)] \r\n        public   char[]   sServerName;\t //服务器名 \r\n        [MarshalAs(UnmanagedType.ByValArray,   SizeConst   =   32)] \r\n        public   char[]   sUserName;\t //用户名 \r\n        [MarshalAs(UnmanagedType.ByValArray,   SizeConst   =   32)] \r\n        public   char[]   sPasswd;\t //密码 \r\n        [MarshalAs(UnmanagedType.ByValArray,   SizeConst   =   64)] \r\n        public   char[]   sFrom;\t //源EMAIL \r\n        [MarshalAs(UnmanagedType.ByValArray,   SizeConst   =   128)] \r\n        public   char[]   sTo;\t //目标EMAIL \r\n        [MarshalAs(UnmanagedType.ByValArray,   SizeConst   =   64)] \r\n        public   char[]   sCC;\t //抄送 \r\n        [MarshalAs(UnmanagedType.ByValArray,   SizeConst   =   64)] \r\n        public   char[]   sBCC;\t //抄送副本 \r\n        public   uint   nReserve;\t //保留 \r\n} \r\n```\r\n```C++\r\npublic override int SetEmail(IntPtr hDev,  string ServerName,  string UserName,  string Passwd,  string From,  string To,  string CC,  string BCC)\r\n{\r\n        DVSNETClient.DVSNET_EMAIL_PARAM dfp = new DVSNETClient.DVSNET_EMAIL_PARAM();\r\n        uint len = (uint)Marshal.SizeOf(dfp);\r\n        IntPtr pdfp = Marshal.AllocHGlobal(Marshal.SizeOf(dfp));\r\n        \r\n        dfp.sServerName = new char[64];\r\n        Array.Copy(ServerName.PadRight(64, \'\\0\').ToCharArray(), dfp.sServerName,64);\r\n        dfp.sUserName = new char[32];\r\n        Array.Copy(UserName.PadRight(32, \'\\0\').ToCharArray(), dfp.sUserName, 32);\r\n        dfp.sPasswd = new char[32];\r\n        Array.Copy(Passwd.PadRight(32, \'\\0\').ToCharArray(), dfp.sPasswd, 32);\r\n        dfp.sFrom = new char[128];\r\n        Array.Copy(From.PadRight(128, \'\\0\').ToCharArray(), dfp.sFrom, 128);\r\n        dfp.sTo = new char[64];\r\n        Array.Copy(To.PadRight(64, \'\\0\').ToCharArray(), dfp.sTo, 64);\r\n        dfp.sBCC = new char[64];\r\n        Array.Copy(BCC.PadRight(64, \'\\0\').ToCharArray(), dfp.sBCC, 64);\r\n        dfp.sCC = new char[64];\r\n        Array.Copy(CC.PadRight(64, \'\\0\').ToCharArray(), dfp.sCC, 64);\r\n\r\n        \r\n\r\n        Marshal.StructureToPtr(dfp, pdfp, true);\r\n        \r\n        int r = SetServerParam(hDev, (uint)(0x10000 + 165), 0, pdfp, len);\r\n        return r;\r\n}\r\n```\r\n\r\n \r\n\r\n\r\n\r\n ","timestamp":1537195820865},{"name":"02-SMTP邮件协议剖析.md","path":"03-程序语言开发/01-C++/02-SMTP邮件协议剖析.md","content":"## SMTP邮件协议剖析  \r\n摘要：本文介绍了一种采用SMTP协议规范并通过直接使用SMTP协议命令而在程序中实现电子邮件传送de方法.并在VC++开发环境下给出了部分关键de实现代码.\r\n\r\n　　**  前言 ** \r\n\r\n　　电子邮件服务作为Internet上应用最多和最广de服务项目得到了非常广泛de应用，在网络应用中也起到非常重要de作用.如同其他de网络服务，电子邮件系统也有其使用de传输协议，包括SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）、POP（Post Office Protocol，邮局协议）和IMAP（Internet Message Access Protocal，消息访问协议）等，这些协议应用于电子邮件de发送和接收.一些邮件处理软件如OutLook Express和FoxMail等就匙按照SMTP和POP3 协议结合Windows Sockets套接字进行设计来收发邮件de.本文以SMTP协议为研究对象，在Visual C++ 6.0编程环境下按照SMTP协议通过套接字发送SMTP命令，接收并处理邮件服务器de反馈信息，从而实现对电子邮件de发送.\r\n\r\n　　** SMTP协议de通讯模型和会话流程 ** \r\n\r\n　　 ** SMTP协议通讯模型 ** \r\n\r\n　　SMTP协议匙TCP/IP协议族中de一员，主要对如何将电子邮件从发送方地址传送到接收方地址，也即匙对传输de规则做了规定.SMTP协议de通信模型并不复杂，主要工作集中在发送SMTP和接收SMTP上：首先针对用户发出de邮件请求，由发送SMTP建立一条连接到接收SMTPde双工通讯链路，这里de接收SMTP匙相对于发送SMTP而言de，实际上它既可以匙最终de接收者也可以匙中间传送者.发送SMTP负责向接收SMTP发送SMTP命令，而接收SMTP则负责接收并反馈应答.可大致用下面de通讯模型示意图来表示：\r\n\r\n![](assets/03/01/02-1524806643000.png)\r\n\r\n　　** SMTP协议de命令和应答 ** \r\n\r\n　　从前面de通讯模型可以看出SMTP协议在发送SMTP和接收SMTP之间de会话匙靠发送SMTPde SMTP命令和接收SMTP反馈de应答来完成de.在通讯链路建立后，发送SMTP发送MAIL命令指令邮件发送者，若接收SMTP此时可以接收邮件则作出OKde应答，然后发送SMTP继续发出RCPT命令以确认邮件匙否收到，如果接收到就作出OKde应答，否则就发出拒绝接收应答，但这并不会对整个邮件操作造成影响.双方如此反复多次，直至邮件处理完毕.SMTP协议共包含10个SMTP命令，列表如下：\r\n\r\nSMTP命令\t命令说明\r\nHELLO ＜domain＞ ＜CRLF＞\t识别发送方到接收SMTPde一个HELLO命令\r\nMAIL FROM:＜reverse-path＞＜CRLF＞\t＜reverse-path＞为发送者地址.此命令告诉接收方一个新邮件发送de开始，并对所有de状态和缓冲区进行初始化.此命令开始一个邮件传输处理，最终完成将邮件数据传送到一个或多个邮箱中.\r\nRCPT TO:＜forward-path＞＜CRLF＞\t＜forward-path＞标识各个邮件接收者de地址\r\nDATA ＜CRLF＞\t\r\n接收SMTP将把其后de行为看作邮件数据去处理，以＜CRLF＞.＜CRLF＞标识数据de结尾.\r\nREST ＜CRLF＞\t退出/复位当前de邮件传输\r\nNOOP ＜CRLF＞\t要求接收SMTP仅做OK应答.（用于测试）\r\nQUIT ＜CRLF＞\t要求接收SMTP返回一个OK应答并关闭传输.\r\nVRFY ＜string＞ ＜CRLF＞\t验证指定de邮箱匙否存在，由于安全因素，服务器多禁止此命令.\r\nEXPN ＜string＞ ＜CRLF＞\t验证给定de邮箱列表匙否存在，扩充邮箱列表，也常禁止使用.\r\nHELP ＜CRLF＞\t查询服务器支持什么命令\r\n\r\n注：＜CRLF＞为回车、换行，ASCII码分别为13、10（十进制）.\r\n\r\n　　SMTP协议de每一个命令都会返回一个应答码，应答码de每一个数字都匙有特定含义de，如第一位数字为2时表示命令成功；为5表失败；3表没有完成.一些较复杂de邮件程序利用该特点，首先检查应答码de首数字，并根据其值来决定下一步de动作.下面将SMTPde应答码列表如下：\r\n\r\n应答码\t说明\r\n501\t参数格式错误\r\n502\t命令不可实现\r\n503\t错误de命令序列\r\n504\t命令参数不可实现\r\n211\t系统状态或系统帮助响应\r\n214\t帮助信息\r\n220\t＜domain＞服务就绪\r\n221\t＜domain＞服务关闭\r\n421\t＜domain＞服务未就绪，关闭传输信道\r\n250\t要求de邮件操作完成\r\n251\t用户非本地，将转发向＜forward-path＞\r\n450\t要求de邮件操作未完成，邮箱不可用\r\n550\t要求de邮件操作未完成，邮箱不可用\r\n451\t放弃要求de操作；处理过程中出错\r\n551\t用户非本地，请尝试＜forward-path＞\r\n452\t系统存储不足，要求de操作未执行\r\n552\t过量de存储分配，要求de操作未执行\r\n553\t邮箱名不可用，要求de操作未执行\r\n354\t开始邮件输入，以\".\"结束\r\n554\t操作失败\r\n\r\n　　在应用程序中使用SMTP协议\r\n\r\n　　** SMTP协议de会话流程 ** \r\n\r\n　　在进行程序设计之前有必要弄清SMTP协议de会话流程，其实前面介绍de内容已经可以大致勾勒出用SMTP发送邮件de框架了，对于一次普通de邮件发送，其过程大致为：先建立TCP连接，随后客户端发出HELLO命令以标识发件人自己de身份，并继续由客户端发送MAIL命令，如服务器应答为\"OK\"，可继续发送RCPT命令来标识电子邮件de收件人，在这里可以有多个RCPT行，而服务器端则表示匙否愿意为收件人接受该邮件.在双方协商结束后，用命令DATA将邮件发送出去，其中对表示结束de\".\"也一并发送出去.随后结束本次发送过程，以QUIT命令退出.下面通过一个实例，从langrui@sohu.com发送邮件到renping@sina.com来更详细直观地描述此会话流程：\r\n\r\nR:220 sina.com Simple Mail Transfer Service Ready\r\nS:HELLO sohu.com\r\nR:250 sina.com\r\nS:MAIL FROM:＜langrui@sohu.com＞\r\nR:250 OK\r\nS:RCPT TO:＜renping@sina.com＞\r\nR:250 OK\r\nS:DATA\r\nR:354 Start mail input;end with \"＜CRLF＞.＜CRLF＞\"\r\nS:……\r\nR:250 OK\r\nS:QUIT\r\nR:221 sina.com Service closing transmission channel\r\n\r\n　　** 邮件de格式化 ** \r\n\r\n　　由于电子邮件结构上de特殊性，在传输时匙不能当作简单de文本来直接处理de，而必须按照一定de格式对邮件头和邮件体进行格式化处理之后才可以被发送.需要进行格式化de部分主要有：发件人地址、收件人地址、主题和发送日期等.在RFC文档deRFC 822里对邮件de格式化有详尽de说明，有关详情请参阅该文档.下面通过VC++6.0按照RFC 822文档规定将格式化邮件de部分编写如下（部分代码）：\r\n```\r\n//邮件头准备\r\nstrTemp = _T( \"From: \" ) + m_strFrom; file://发件人地址  \r\nadd_header_line( (LPCTSTR)strTemp );  \r\nstrTemp = _T( \"To: \" ) + m_strTo; file://收件人地址\r\nadd_header_line( (LPCTSTR)strTemp );\r\nm_tDateTime = m_tDateTime.GetCurrentTime();//发送时间\r\nstrTemp = _T( \"Data: \" );\r\nstrTemp += m_tDateTime.Format( \"%a, %d %b %y %H:%M:%S %Z\" );\r\nadd_header_line( (LPCTSTR)strTemp );\r\nstrTemp = _T( \"Subject: \" ) + m_strSubject; file://主题\r\nadd_header_line( (LPCTSTR)strTemp );\r\nfile://邮件头结束\r\nm_strHeader += _T( \"\\r\\n\" );\r\nfile://邮件体准备\r\nif( m_strBody.Right( 2 ) != _T( \"\\r\\n\" ) ) file://确认最后以回车换行结束\r\nm_strBody += _T( \"\\r\\n\" );\r\n```\r\n　　其中add_header_line(LPCTSTR szHeaderLine)函数用于把szHeaderLine指向de字串追加到m_strHeader后面.其中，格式化后de邮件头保存在m_strHeader里，格式化后de邮件体保存在m_strBody中.\r\n\r\n　　由Socket套接字为SMTP提供网络通讯基础\r\n\r\n　　许多网络程序都匙采用Socket套接字实现de，对于一些标准de网络协议如HTTP、FTP和SMTP等协议de编程也匙基于套接字程序de，只匙端口号不再匙随意设定而要由协议来指定，比如HTTP端口在80、FTP匙21，而SMTP则匙25.Socket只匙提供在指定de端口上同指定de服务器从事网络上de通讯能力，至于客户和服务器之间匙如何通讯de则由网络协议来规定，这对于套接字匙完全透明de.因此可以使用Socket套接字为程序提供网络通讯de能力，而对于网络通讯连路建立好之后采取什么样de通讯应答则要按SMTP协议de规定去执行了.Socket套接字网络编程方面de文章资料非常丰富，限于本文篇幅，在此不再赘述，有关详情请参阅相关文档.为简便起见，没有采用编写较复杂deWindows Sockets API进行编程，而匙使用经过较好封装deMFC deCSocket类.在正式使用套接字之前，也要先用AfxSocketInit()函数对套接字进行初始化，然后用Create()创建套接字对象，并由该套接字通过Connect（）建立同邮件服务器de连接.如果一切正常，再后续de工作中就匙遵循SMTP协议de约定来使用Send（）、Receive()函数来发送SMTP命令和接收邮件服务器发来de应答码以完成对邮件de传送.\r\n\r\n　　** SMTP会话应答de实现 ** \r\n\r\n　　在同邮件服务器建立好链路连接后就可以按前面介绍过de会话流程进行程序设计了，对于SMTP命令de发送，可按命令格式将其组帧完毕后用CSocket类deSend()函数将其发送到服务器，并通过CSocket类deReceive()函数接收从邮件服务器发来de应答码，并根据SMTP协议de应答码表对其做出响应de处理.下面匙用于接收应答码de函数get_response()de部分实现代码：\r\n```\r\nBOOL CSMTP::get_response( UINT response_expected )//输入参数为希望de应答码\r\n{\r\n……\r\n// m_wsSMTPServer为CSocketde类对象，调用Receive()将应答码接收到缓存\r\n// response_buf中\r\nm_wsSMTPServer.Receive( response_buf, RESPONSE_BUFFER_SIZE )\r\nsResponse = response_buf;\r\nsscanf( (LPCTSTR)sResponse.Left( 3 ), _T( \"%d\" ), &response );\r\npResp = &response_table[ response_expected ];\r\nfile://检验收到de应答码匙否匙所希望得到de\r\nif( response != pResp-＞nResponse )\r\n{\r\n……//不相等de话进行错误处理\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\n```\r\n　　会话de各个部分比较类似，都匙命令--应答方式，而且均成对出现，下面匙本文de重点也匙实现de关键部分--在程序控制下完成对SMTP命令de格式化以及对命令de发送和对邮件服务器应答码de检验处理：\r\n```\r\n//格式化并发送HELLO命令，并接收、验证服务器应答码\r\ngethostname( local_host, 80 );\r\nsHello.Format( _T( \"HELO %s\\r\\n\" ), local_host );\r\nm_wsSMTPServer.Send( (LPCTSTR)sHello, sHello.GetLength() );\r\nif( !get_response( GENERIC_SUCCESS ) ) file://检验应答码匙否为250\r\n{\r\n……\r\nreturn FALSE;\r\n}\r\nfile://格式化并发送MAIL命令，并接收、验证服务器应答码\r\nsFrom.Format( _T( \"MAIL From: ＜%s＞\\r\\n\" ), (LPCTSTR)msg-＞m_strFrom );\r\nm_wsSMTPServer.Send( (LPCTSTR)sFrom, sFrom.GetLength() );\r\nif( !get_response( GENERIC_SUCCESS ) ) file://检验应答码匙否为250\r\nreturn FALSE;\r\nfile://格式化并发送RCPT命令，并接收、验证服务器应答码\r\nsEmail=(LPCTSTR)msg-＞m_strTo;\r\nsTo.Format( _T( \"RCPT TO: ＜%s＞\\r\\n\" ), (LPCTSTR)sEmail );\r\nm_wsSMTPServer.Send( (LPCTSTR)sTo, sTo.GetLength() );\r\nif(!get_response( GENERIC_SUCCESS )) file://检验应答码匙否为250\r\nreturn FALSE;\r\nfile://格式化并发送DATA命令，并接收、验证服务器应答码\r\nsTemp = _T( \"DATA\\r\\n\" );\r\nm_wsSMTPServer.Send( (LPCTSTR)sTemp, sTemp.GetLength() );\r\nif( !get_response( DATA_SUCCESS ) ) file://检验应答码匙否为354\r\nreturn FALSE;\r\nfile://发送根据RFC 822文档规定格式化过de邮件头\r\nm_wsSMTPServer.Send( (LPCTSTR)msg-＞m_strHeader, msg-＞m_strHeader.GetLength() );\r\n……\r\nfile://发送根据RFC 822文档规定格式化过de邮件体\r\nsTemp = msg-＞m_strBody;\r\nif( sTemp.Left( 3 ) == _T( \".\\r\\n\" ) )\r\nsTemp = _T( \".\" ) + sTemp;\r\nwhile( (nPos = sTemp.Find( szBad )) ＞ -1 )\r\n{\r\nsCooked = sTemp.Mid( nStart, nPos );\r\nsCooked += szGood;\r\nsTemp = sCooked + sTemp.Right( sTemp.GetLength() - (nPos + nBadLength) );\r\n}\r\nm_wsSMTPServer.Send( (LPCTSTR)sTemp, sTemp.GetLength() );\r\nfile://发送内容数据结束标志\"＜CRLF＞.＜CRLF＞\"，并检验返回应答码\r\nsTemp = _T( \"\\r\\n.\\r\\n\" );\r\nm_wsSMTPServer.Send( (LPCTSTR)sTemp, sTemp.GetLength() );\r\nif( !get_response( GENERIC_SUCCESS ) )// 检验应答码匙否为250\r\nreturn FALSE;\r\n```\r\n　　到此为止，已基本在程序中体现出了SMTP协议de会话流程，能在Socket套接字所提供de网络通讯能力基础之上实现以SMTP命令和SMTP应答码为基本会话内容de通讯交互过程，从而最终实现SMTP协议对电子邮件de发送.\r\n\r\n　　** 结论 ** \r\n\r\n　　电子邮件类软件作为Internet上de应用软件，其设计开发必须符合Internet上成熟de技术规范（如RFC文档系列规范）和相关协议（如POP、SMTP、IMAP以及LDAP等）.只有在遵循了上述规范和协议de基础上进行编程才能真正实现邮件类软件产品和服务de开放性和标准化.本文着重对SMTP协议及其在VC++编程中de应用做了介绍，并按照SMTP协议对电子邮件de发送进行了开放性和标准性较好de程序设计.本文所述程序在Windows 98下，由Microsoft Visual C++ 6.0编译通过.\r\n来源： <http://www.woaidiannao.com/dnbc/6077.html>\r\n ","timestamp":1537195820865},{"name":"03-基础知识备忘.md","path":"03-程序语言开发/01-C++/03-基础知识备忘.md","content":"### 基础知识备忘\r\n在日常生活中，我们会不断学习新的知识，但是有些知识因时间的长久而淡忘，可能会一提起会想起，但有些时候却彻底遗忘。好记性不如烂笔头，我要记下点点滴滴。\r\n\r\n- c语言中的scanf与scanf_s区别\r\n在我们初学时候写win32程序常常会用到scanf来输入字符，但是这些程序一旦运行在vs环境中scanf常常会warning，甚至会error。  \r\n原因是因为在微软在vs这个IDE中针对部分方法进行安全性考虑，这类方法最明显的区别就说在函数方法后面多了_s。  \r\n那么scanf与scanf_s在用法上有什么区别。\r\n示例说话：\r\n```C++\r\nchar n;\r\nscanf_s(\"%c\",&n,1);\r\nprintf(\"输入数据为：%c\",n);\r\n```\r\n```c++\r\nchar n[5]={\"\\0\"};\r\nscanf_s(\"%s\",&n,4); //此处最多只能输入3个字符，超过则会出现位置现象，最直观就是赋值失败\r\nprintf(\"输入数据为：%s\",n);\r\nscanf(\"%s\",&n);   //如果上面输入过多字符，在这里会接收到。  如果这里输入超过数组的长度则会运行异常，最多只能输入4个字符。\r\nprintf(\"输入数据为：%s\\r\\n\",n);\r\n```\r\n\r\n- ifstream open 相对路径问题\r\n\r\n```c++\r\nbool CElecDictionary::Init(string DicFileName)\r\n{\r\n\ttry\r\n\t{\r\n\t\tif(m_bInit)\r\n\t\t\treturn true;\r\n\r\n\t\tifstream inFile;\r\n\t\tm_strDicName = DicFileName;\r\n\t\tinFile.open(m_strDicName.c_str());//此处直接传相对路径文件读取失败，绝对路径正常\r\n\t\tstring strLineInfo;\r\n\r\n\t\twhile(!inFile.eof())\r\n\t\t{\r\n\t\t\tgetline(inFile , strLineInfo);\r\n\r\n\t\t\tif(strLineInfo == \"\") \r\n\t\t\t\tbreak;\r\n\t\t\tchar_separator<char> sep(\"\\t\");\r\n\t\t\ttokenizer<char_separator<char>> tok(strLineInfo,sep);\r\n\t\t\t{\r\n\t\t\t\ttokenizer<char_separator<char>>::iterator beg = tok.begin();\r\n\t\t\t\tstring strEInfo = *beg;\r\n\t\t\t\tbeg++;\r\n\t\t\t\tstring strCInfo = *beg;\r\n\t\t\t\t\r\n\t\t\t\tm_mapDic.left.insert(make_pair(strEInfo,strCInfo));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```\r\n- ","timestamp":1537195820865},{"name":"04-仿函数.md","path":"03-程序语言开发/01-C++/04-仿函数.md","content":"### 仿函数学习\r\n\r\n来源：https://blog.csdn.net/tianshuai1111/article/details/7687983\r\n\r\n一，概述\r\n         仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。\r\n 　　有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。\r\n\r\n​\t1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。\r\n\r\n​\t 2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。\r\n\r\n二，仿函数(functor)在各编程语言中的应用\r\n\r\n1）C语言使用**函数指针**和**回调函数**来实现仿函数，例如一个用来排序的函数可以这样使用仿函数 　　\r\n\r\n```c++\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n//int sort_function( const void *a, const void *b);\r\nint sort_function( const void *a, const void *b)\r\n{   \r\n\treturn *(int*)a-*(int*)b;\r\n}\r\nint main()\r\n{\r\n    int list[5] = { 54, 21, 11, 67, 22 };\r\n    qsort((void *)list, 5, sizeof(list[0]), sort_function);//起始地址，个数，元素大小，回调函数 \r\n    int  x;\r\n    for (x = 0; x < 5; x++)\r\n        printf(\"%i\\n\", list[x]);\r\n    return 0;\r\n}\r\n```\r\n\r\n2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。 \r\n\r\n```c++\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\ntemplate<typename T>\r\nclass display\r\n{\r\npublic:\r\n    void operator()(const T &x)\r\n\t{\r\n\t\tcout<<x<<\" \"; \r\n\t} \r\n}; \r\nint main()\r\n{\r\n\tint ia[]={1,2,3,4,5};\r\n\tfor_each(ia,ia+5,display<int>()); \r\n\treturn 0; \r\n} \r\n```\r\n\r\n 三，仿函数在STL中的定义 \r\n\r\n要使用STL内建的仿函数，必须包含<functional>头文件。而头文件中包含的仿函数分类包括\r\n\r\n​1）算术类仿函数\r\n\r\n    加：plus<T>\r\n\r\n    减：minus<T>\r\n\r\n    乘：multiplies<T>\r\n\r\n    除：divides<T>\r\n\r\n    模取：modulus<T>\r\n\r\n    否定：negate<T>\r\n\r\n例子：\r\n\r\n```c++\r\n#include <iostream>\r\n#include <numeric>\r\n#include <vector> \r\n#include <functional> \r\nusing namespace std;\r\nint main()\r\n{\r\n\tint ia[]={1,2,3,4,5};\r\n\tvector<int> iv(ia,ia+5);\r\n\tcout<<accumulate(iv.begin(),iv.end(),1,multiplies<int>())<<endl; \r\n\tcout<<multiplies<int>()(3,5)<<endl;\r\n\tmodulus<int>  modulusObj;\r\n\tcout<<modulusObj(3,5)<<endl; // 3 \r\n\treturn 0; \r\n} \r\n```\r\n​2）关系运算类仿函数   \r\n- 等于：equal_to<T>  \r\n- 不等于：not_equal_to<T>  \r\n- 大于：greater<T>  \r\n- 大于等于：greater_equal<T>  \r\n- 小于：less<T>  \r\n- 小于等于：less_equal<T>  \r\n- 从大到小排序：  \r\n```c++\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <vector> \r\nusing namespace std;\r\ntemplate <class T> \r\nclass display\r\n{\r\npublic:\r\n\tvoid operator()(const T &x)\r\n\t{\r\n\t\tcout<<x<<\" \"; \r\n\t} \r\n};\r\nint main()\r\n{\r\n\tint ia[]={1,5,4,3,2};\r\n\tvector<int> iv(ia,ia+5);\r\n    sort(iv.begin(),iv.end(),greater<int>());\r\n\tfor_each(iv.begin(),iv.end(),display<int>()); \r\n\treturn 0; \r\n} \r\n```\r\n 3）逻辑运算仿函数   \r\n- 逻辑与：logical_and<T>  \r\n- 逻辑或：logical_or<T>  \r\n- 逻辑否：logical_no<T>  ","timestamp":1537195820865},{"name":"05-vector迭代器失效问题.md","path":"03-程序语言开发/01-C++/05-vector迭代器失效问题.md","content":"### vector 迭代器失效测试\r\n\r\n#### 失效样例\r\n```C++\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;  \r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\tvector<int> a;\r\n\ta.push_back(1);\r\n\ta.push_back(2);\r\n\ta.push_back(3);\r\n\ta.push_back(4);\r\n\ta.push_back(5);\r\n\r\n\tvector<int>::iterator iterator = a.begin();\r\n\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tcout<< &(*iterator) << \" \" << *iterator <<endl;\r\n\t}\r\n\t\r\n\titerator = a.begin();\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tif( 2 == *iterator )\r\n\t\t{\r\n            a.erase(iterator);\r\n\t\t}\r\n\t}\r\n\r\n\titerator = a.begin();\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tcout<< &(*iterator) << \" \" << *iterator <<endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\n此样例在代码编译时通过，但在运行时出现问题。经过调试发现出现问题时在vector执行erase后出现的。因此我们可以确定vector的迭代器失效是在erase之后产生的，那么为什么会出现此问题。\r\n\r\n#### 优化代码1\r\n```c++\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;  \r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\tvector<int> a;\r\n\ta.push_back(1);\r\n\ta.push_back(2);\r\n\ta.push_back(3);\r\n\ta.push_back(4);\r\n\ta.push_back(5);\r\n\r\n\tvector<int>::iterator iterator = a.begin();\r\n\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tcout<< &(*iterator) << \" \" << *iterator <<endl;\r\n\t}\r\n\t\r\n\titerator = a.begin();\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tif( 2 == *iterator || 3 == *iterator)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = a.erase(iterator);\r\n\t\t\titerator = it;\r\n\t\t}\r\n\t}\r\n\r\n\titerator = a.begin();\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tcout<< &(*iterator) << \" \" << *iterator <<endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\n现在我希望删除2和3元素，但是此次的代码会发现我们并没有删除值为3的元素，那么是为什么呢？\r\n#### 再次优化\r\n```C++\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <string>\r\n#include <vector>\r\n#include <list>\r\n#include <iostream>\r\n#include <fstream>\r\nusing namespace std;  \r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\tvector<int> a;\r\n\ta.push_back(1);\r\n\ta.push_back(2);\r\n\ta.push_back(3);\r\n\ta.push_back(4);\r\n\ta.push_back(5);\r\n\r\n\tvector<int>::iterator iterator = a.begin();\r\n\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tcout<< &(*iterator) << \" \" << *iterator <<endl;\r\n\t}\r\n\t\r\n\titerator = a.begin();\r\n\tfor (;iterator!=a.end();)\r\n\t{\r\n\t\tif( 2 == *iterator || 3 == *iterator)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = a.erase(iterator);\r\n\t\t\titerator = it;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t++iterator;\r\n\t\t}\r\n\t}\r\n\r\n\titerator = a.begin();\r\n\tfor (;iterator!=a.end();++iterator)\r\n\t{\r\n\t\tcout<< &(*iterator) << \" \" << *iterator <<endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\nvector在erase指定位置的元素时：  \r\n返回值是一个迭代器，指向删除元素下一个元素;如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素;","timestamp":1537195820865},{"name":"06-结构体作为map的key值.md","path":"03-程序语言开发/01-C++/06-结构体作为map的key值.md","content":"### map中以结构体作为key\r\n\r\n在map中以结构体作为key值，需要将<进行重载，用于比较或者find。\r\n\r\n```C++\r\n#include \"stdafx.h\"\r\n#include <iostream>\r\n#include <map>\r\nstruct SStudent\r\n{\r\n\tstd::string Name;\r\n\tstd::string Code;\r\n\r\n\tbool operator < (const SStudent &stOther) const \r\n\t{\r\n\t\treturn Name.compare(stOther.Name) < 0 && Code.compare(stOther.Code) ? true : false;\r\n\t}\r\n};\r\ntypedef std::map<SStudent,int> StudentMap;\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\tStudentMap _map;\r\n\tSStudent _student;\r\n\t_student.Name = \"jj\";\r\n\t_student.Code = \"123\";\r\n\t_map.insert(std::make_pair(_student,1));\r\n\tSStudent _temp;\r\n\t_temp.Name = \"jj\";\r\n\t_temp.Code = \"123\";\r\n\tStudentMap::iterator it = _map.find(_temp);\r\n\t\r\n\t//do other thing\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n ```","timestamp":1537195820865},{"name":"01-C# 实现窗口无边框，可拖动效果.md","path":"03-程序语言开发/02-CSharp/01-C# 实现窗口无边框，可拖动效果.md","content":"## C#窗口无边框，可拖动效果实现代码\r\n```C#\r\n#region 无边框拖动效果\r\n[DllImport(\"user32.dll\")]//拖动无窗体的控件\r\npublic static extern bool ReleaseCapture();\r\n[DllImport(\"user32.dll\")]\r\npublic static extern bool SendMessage(IntPtr hwnd, int wMsg, int wParam, int lParam);\r\npublic const int WM_SYSCOMMAND = 0x0112;\r\npublic const int SC_MOVE = 0xF010;\r\npublic const int HTCAPTION = 0x0002;\r\n\r\nprivate void Start_MouseDown(object sender, MouseEventArgs e)\r\n{\r\n   //拖动窗体\r\n   ReleaseCapture();\r\n   SendMessage(this.Handle, WM_SYSCOMMAND, SC_MOVE + HTCAPTION, 0);\r\n}\r\n#endregion\r\n```  \r\n在窗口属性界面添加事件服务  \r\n![](assets/03/20180323-cab99363.png)  \r\n","timestamp":1537195820865},{"name":"02-ToString方法一些特殊用法.md","path":"03-程序语言开发/02-CSharp/02-ToString方法一些特殊用法.md","content":"## ToString()用法\r\n### 取中文日期显示\r\n1. 年月日时分  \r\n urrentTime.ToString(\"f\"); //不显示秒    \r\n1. 年月  \r\n currentTime.ToString(\"y\");  \r\n1. 月日  \r\n currentTime.ToString(\"m\");  \r\n1. 格式为：2003-9-23\r\n currentTime.ToString(\"d\");  \r\n1. 格式为：14:24   \r\n currentTime.ToString(\"t\");  \r\n\r\n### 字符型转换 转为字符串\r\n12345.ToString(\"n\"); //结果：12,345.00  \r\n12345.ToString(\"C\");//结果：￥12,345.00  \r\n12345.ToString(\"e\"); //结果：1.234500e+004  \r\n12345.ToString(\"f4\");//结果：12345.0000  \r\n12345.ToString(\"x\"); //结果：3039 (16进制)  \r\n12345.ToString(\"p\");//结果：1,234,500.00%  \r\n\r\n---\r\n\r\n### datetime\r\n令DateTime.Now为2007-7-17 22:07:24  \r\n1. DateTime.Now.ToString(\"yy－MM－dd\")  \r\n处理后：07-07-17  \r\n1. DateTime.Now.ToString(\"yy年MM月dd日\")  \r\n处理后：07年07月17日（中文样式）  \r\n","timestamp":1537195820865},{"name":"03-简易缓冲池的建立.md","path":"03-程序语言开发/02-CSharp/03-简易缓冲池的建立.md","content":"# 简易缓冲池  \r\n在程序通信中，如果遇到数据量稍微大的时候，处理的不及时会造成数据挤压，甚至程序卡死。因此在设计时设计一个缓冲池，用于存储消息是必须的。当然只是一个简易的受限很大，谢谢小程序用用还行。  \r\n首先定义缓冲池结构体，为啥用结构体，你懂得！  \r\n```C#\r\npublic struct _loop_buf\r\n{\r\n    public int nUnitMaxCount;  // Number of data units\r\n    public int nUnitSize;\r\n    public int nReadPos; // Head for read\r\n    public int nWritePos; // Head for write\r\n    public byte[] byteDataBuf;\r\n};\r\n```\r\n缓冲池初始化，设置缓冲池每个存储单元的大小和缓冲池存储的最大数  \r\n```C#\r\n/// <summary>\r\n///缓冲池初始化\r\n/// </summary>\r\n/// <param name=\"nMaxCount\"></param>\r\n/// <param name=\"nSize\"></param>\r\n/// <returns>\r\n/// 0 返回正确 , -1 分配内存太大 0x7fffffff ,-2 存储单元最大数量太大 0x7ffffff0,-3 不能分配如此大的内存大小\r\n/// </returns>\r\npublic static int Init(ref _loop_buf loop_buf, int nMaxCount, int nSize)\r\n{\r\n    ulong total_size;\r\n    //loop_buf->buf_head = NULL;\r\n    total_size = (ulong)nMaxCount * (ulong)nSize;\r\n    if (total_size > 0x7fffffff) {\r\n        return -1;\r\n    }\r\n\r\n    if (nMaxCount > 0x7ffffff0)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    loop_buf.nUnitMaxCount = nMaxCount;\r\n    loop_buf.nUnitSize = nSize;\r\n    loop_buf.nReadPos = 0;\r\n    loop_buf.nWritePos = 0;\r\n\r\n    try\r\n    {\r\n        loop_buf.byteDataBuf = new byte[total_size];\r\n    }\r\n    catch (System.Exception ex)\r\n    {\r\n        return -3;\r\n    }\r\n    return 0;\r\n}\r\n```\r\n剩下的就是对缓冲池的常规操作了，重置，写入数据，取出数据等操作；  \r\n```C#\r\n/// <summary>\r\n/// 重置缓存池\r\n/// </summary>\r\n/// <param name=\"loop_buf\"></param>\r\npublic static void reset_loop_buf(ref _loop_buf loop_buf)\r\n{\r\n    loop_buf.nReadPos = 0;\r\n    loop_buf.nWritePos = 0;\r\n}\r\n\r\n/// <summary>\r\n/// 从换成池中读取数据\r\n/// </summary>\r\n/// <param name=\"loop_buf\"></param>\r\n/// <param name=\"byteData\"></param>\r\n/// <returns>\r\n/// 0 返回正确\r\n/// -1 缓冲池为空\r\n/// </returns>\r\npublic static int read_data_from_loop_buf(ref _loop_buf loop_buf, ref byte[] byteData)\r\n{\r\n    if (loop_buf.nReadPos == loop_buf.nWritePos)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    Array.Copy(loop_buf.byteDataBuf, loop_buf.nReadPos* loop_buf.nUnitSize, byteData, 0, loop_buf.nUnitSize);\r\n    if (loop_buf.nReadPos== (loop_buf.nUnitMaxCount - 1))\r\n    {\r\n        loop_buf.nReadPos = 0;\r\n    }\r\n    else\r\n    {\r\n        loop_buf.nReadPos++;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/// <summary>\r\n/// 将数据写入缓冲区\r\n/// </summary>\r\n/// <param name=\"loop_buf\"></param>\r\n/// <param name=\"byteData\"></param>\r\n/// <returns>\r\n/// 0 返回正常\r\n/// -1 缓冲区已经满了\r\n/// </returns>\r\npublic static int write_data_to_loop_buf(ref _loop_buf loop_buf, byte[] byteData)\r\n{\r\n    int nTempWritePos = 0;\r\n\r\n    nTempWritePos = loop_buf.nWritePos + 1;\r\n    if (nTempWritePos >= loop_buf.nUnitMaxCount)\r\n    {\r\n        nTempWritePos = 0;\r\n    }\r\n\r\n    if (nTempWritePos == loop_buf.nReadPos)\r\n    {\r\n        // The buffer is full.\r\n        return -1;\r\n    }\r\n\r\n    Array.Copy(byteData, 0, loop_buf.byteDataBuf, loop_buf.nWritePos * loop_buf.nUnitSize, loop_buf.nUnitSize);\r\n\r\n    loop_buf.nWritePos = nTempWritePos;\r\n\r\n    return 0;\r\n}\r\n\r\n/// <summary>\r\n/// 从缓冲区中获取数据\r\n/// </summary>\r\n/// <param name=\"loop_buf\"></param>\r\n/// <returns></returns>\r\npublic static byte[] get_data_from_loop_buf(ref _loop_buf loop_buf)\r\n{\r\n    if (loop_buf.nReadPos == loop_buf.nWritePos) \r\n    {\r\n        // The buffer is null.\r\n        return null;\r\n    }\r\n    byte[] byteResult = new byte[loop_buf.nUnitSize];\r\n    Array.Copy(loop_buf.byteDataBuf, loop_buf.nReadPos * loop_buf.nUnitSize, byteResult, 0, loop_buf.nUnitSize);\r\n    return byteResult;\r\n}\r\n```\r\n","timestamp":1537195820865},{"name":"04-Net开源项目.md","path":"03-程序语言开发/02-CSharp/04-Net开源项目.md","content":"## 综合类\r\n\r\n1.  [微软企业库](https://entlib.codeplex.com/)&nbsp;微软官方出品,是为了协助开发商解决企业级应用开发过程中所面临的一系列共性的问题, 如安全(Security)、日志(Logging)、数据访问(Data Access)、配置管理(Configuration Manage)等，并将这些广泛使用的应用程序块集成封装至一个叫企业库的程序包中\r\n2.  [CommonLibrary.net](https://commonlibrarynet.codeplex.com/)&nbsp;一个帮助类库,包含了ActiveRecord, Csv, Command Line Parsing, Configuration, Validation, Logging, Collections, Authentication等等\r\n3.  [Castle](http://www.castleproject.org/)&nbsp;一个传统的综合类库,包含IOC容器,基于ActiveRecord模式的ORM,类MVC框架,核心,现在用的比较多的是核心Castle.Core, 里面包含了基于虚拟工厂的日志抽象,动态代理DynamicProxy,Dictionary Adapter(可以将一个接口转化为强类型的Dictionary对象,具体大家可以查一查,某些场景下很有用)\r\n\r\n## <a name=\"t1\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>IOC容器\r\n\r\n1.  [Autofac](https://code.google.com/p/autofac/)&nbsp;我最喜欢的一个IOC容器,特性丰富,除了IOC的基本功能外,还提供模块化和程序集扫描,内置了很多有用的扩展(Lazy,Func,Owned,IEnumrable)等等,而且对asp.net,mvc,mef,wcf,dynamicProxy等等提供了集成.\r\n2.  [Unity](https://unity.codeplex.com/)&nbsp;微软企业库的基础,功能简单,扩展方便,微软官方提供一个EventBus的扩展例子,值得一看\r\n3.  [Ninject](http://www.ninject.org/)&nbsp;主打特性简单易用,很多讲MVC的书中都用这个做例子\r\n4.  [StructureMap](http://docs.structuremap.net/)&nbsp;一个传统的IOC容器,很早就出来了,性能优越,功能稳定,已经不更新了(在一个IOC容器的性能测试中性能最佳)\r\n\r\n## <a name=\"t2\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>ORM框架\r\n\r\n1.  [NHibernate](https://github.com/nhibernate)&nbsp;一个传统的ORM,移植于java的Hibernate,3.0后发展迅速,提供FluentMap和FluentConfig,支持Linq,支持 HQL和NativeSQL,支持一级缓存和二级缓存,丰富的ID生成策略,更多的拦截事件暴露,支持常见的所有数据库,缺点就是配置选项有点多,初学者无处下手\r\n2.  [EntityFramework](http://www.cnblogs.com/Mercurius/admin/)&nbsp;微软官方出的ORM,配置简单,比NH更好的Linq支持,工具支持和较低的学习门槛,命名约定配置,支持CodeFirst DbMigration(在开发时,不能用在生产环境中),缺点就是不支持批量操作(第三方库EntityFramework.Extension扩展了这一点,还做了缓存),无原生的二级缓存,,单调的ID生成方式,不支持多数据库(很多数据库如MySql都对EF提供了支持,但是bug多多,有稳定的商业库可以选择),还有单一的配置方式(当你想从程序集动态加载model到DbContext中时,你就会知道就多捉鸡)\r\n3.  [Dapper](http://code.google.com/p/dapper-dot-net/)&nbsp;StackOverflow开源的一个MiniOrm,性能和原生ado.net相近,0配置,强类型支持.缺点同样是有小bug,较弱的LINQ支持 (只找到一个MSSQL的linq插件)有两个关于Dapper的扩展,一个叫Dapper.Extension,一个叫 Dapper.Rainbow.Mysql.这两个扩展可能更接近传统意义上的ORM\r\n4.  [ServiceStack.OrmLite](https://github.com/ServiceStack/ServiceStack.OrmLite)&nbsp;另外一个MiniORM,性能仅次于Dapper,支持大部分的数据库,比Dapper丰富的多的API和更好的强类型lambda表达式查询条件支持,映射0配置,也支持以Attribute配置,支持表的创建和删除,好东西.我最喜欢~~\r\n\r\n## <a name=\"t3\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>文档操作\r\n\r\n1.  [EppPlus](https://epplus.codeplex.com/)&nbsp;使用xlsx协议读写Excel2007/2010,功能非常多\r\n2.  [DocX](https://docx.codeplex.com/)&nbsp;读写Word2007/2010文件,无需安装office\r\n3.  [PdfSharp](https://pdfsharp.codeplex.com/)&nbsp;操作pdf\r\n\r\n## <a name=\"t4\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>基础类库\r\n\r\n1.  [AutoMapper](https://automapper.codeplex.com/)&nbsp;对象映射,常用来做DTO/ViewModel和Model之间的映射,功能丰富远超你想象\r\n2.  [Html Agility Pack](https://htmlagilitypack.codeplex.com/)Html解析库\r\n3.  [Json.net](https://json.codeplex.com/)&nbsp;Json序列化和反序列化,基本支持所有的json特性,性能也很好,MVC4的默认引用程序集中已包含.(支持4.0的动态对象,这个很好用)\r\n4.  [FluentValidation](https://fluentvalidation.codeplex.com/)&nbsp;类似于4.0新出的代码契约,用于对业务对象创建验证规则.其本身已经内置了很多的规则\r\n5.  [DotNetZip&nbsp;](https://dotnetzip.codeplex.com/)创建,压缩,解压Zip文件\r\n6.  [SharpZipLib](http://www.icsharpcode.net/)&nbsp;创建,压缩,解压Zip文件\r\n7.  [SevenZipSharp](https://sevenzipsharp.codeplex.com/)&nbsp;支持7zip所有格式的压缩和解压缩\r\n8.  [Rx](https://rx.codeplex.com/)&nbsp;使用可观测对象(IObservable)的序列和 LINQ 风格的查询操作来编写异步和基于事件的程序。开发人员可通过 Rx 使用可观测对象来表示异步数据流，并使用 LINQ 操作来查询异步数据流。简而言之：Rx = Observables + LINQ + Schedulers.\r\n9.  [Microsoft.Bcl.Async](https://www.nuget.org/packages/Microsoft.Bcl.Async)&nbsp;可以在4.0中使用4.5中新增的async和await两个关键字\r\n\r\n## <a name=\"t5\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>辅助开发\r\n\r\n1.  [Autoupdate](https://autoupdaterdotnet.codeplex.com/)&nbsp;为你的程序一键增加更新功能\r\n2.  [NetSparkle&nbsp;](https://netsparkle.codeplex.com/)一个独立的升级框架,不依赖于你的程序和代码\r\n3.  [MailSystem.NET](https://mailsystem.codeplex.com/)&nbsp;功能强大的电子邮件组件,提供对SMTP, POP3, IMAP4, NNTP, MIME, S/MIME, OpenPGP, DNS, vCard, vCalendar, Anti-Spam (Bayesian , RBL, DomainKeys), Queueing, Mail Merge and WhoIs的支持\r\n4.  [FluentMigrator](https://github.com/schambers/fluentmigrator)&nbsp;一个类似于RubyMigrations的数据库Migration框架\r\n5.  [GMap.Net](https://greatmaps.codeplex.com/)&nbsp;一个强大的.NET地图控件,可以用于Winform和WPF,跨平台,支持 Coogle, Yahoo!, Bing, OpenStreetMap, ArcGIS, Pergo, SigPac, Yandex, Mapy.cz, Maps.lt, iKarte.lv, NearMap, OviMap, CloudMade, WikiMapia, MapQuest ,同学们可以根据需求扩展国内的版本.\r\n\r\n## <a name=\"t6\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>企业总线\r\n\r\n1.  [Shuttle ESB](https://shuttle.codeplex.com/)&nbsp;一个开源的企业总线,C#编写,不依赖第三方程序集,支持MSMQ和table-based queue\r\n2.  [NServiceBus](http://particular.net/nservicebus)&nbsp;最流行的.NET开源总线,不依赖于xml配置,支持MSMQ, RabbitMQ, ActiveMQ, WebSphereMQ, Azure,其次配套设施十分齐全,比如对autofac的集成\r\n\r\n## <a name=\"t7\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>服务器\r\n\r\n1.  [Katana](https://katanaproject.codeplex.com/)&nbsp;包含一系列的服务器组件,用来创建自包含的web应用程序.\r\n2.  [CassiniDev](https://cassinidev.codeplex.com/)&nbsp;开源的asp.net服务器,IIS的替代品\r\n3.  [IISTuner](https://iistuner.codeplex.com/)&nbsp;IIS配置优化工具\r\n\r\n## <a name=\"t8\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>图形图像\r\n\r\n1.  [SharpGL](https://sharpgl.codeplex.com/)&nbsp;OpenGL的C#封装,更新很\r\n\r\n2.  快,基本可以与Glew保持一致.\r\n\r\n3.  [Magick.NET](https://magick.codeplex.com/)&nbsp;强大的图片处理库,可以处理超过100种格式,无需安装ImageMagick\r\n4.  [DotNet.Highcharts](https://dotnethighcharts.codeplex.com/)&nbsp;Highcharts的封装,用于asp.net,强类型和智能提示,渣前端开发者的福音.\r\n\r\n## <a name=\"t9\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>日志\r\n> 日志框架如何选择如果你使用了微软企业库,就用企业库自带的,如果你引入的程序集中有的使用了Log4net,那就最好使用Log4net,如果都没有,看个人喜好\r\n\r\n1.  [Log4net](http://logging.apache.org/log4net/)&nbsp;传统的日志框架,移植于log4jV1.2,高效,稳定\r\n2.  [NLog](https://github.com/nlog/NLog/)&nbsp;官方介绍为高级日志框架,与Log4net相比,有比较强的配置文件自纠错能力,更加丰富的LogAppender.\r\n3.  [Logging Application Block](https://entlib.codeplex.com/releases/view/101823)&nbsp;微软企业库自带的日志记录模块\r\n4.  [Semantic Logging Application Block](https://entlib.codeplex.com/releases/view/101823)&nbsp;微软企业库新出的日志记录框架,理念上不同于前面三个,具体可以参考http://blogs.msdn.com/b/agile/archive/2013/02/07/embracing-semantic-logging.aspx\r\n\r\n## <a name=\"t10\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>CMS\r\n\r\n1.  [Orchard](http://www.orchardproject.net/)&nbsp;CMS的新起之秀,基于Asp.net MVC.扩展很多.非常值得作为源码学习(值得学习的模块有IOC的深度应用,基于IOC的EventBus,高度抽象的模板系统,Cache,插件化体系,基于NH的数据迁移框架)\r\n2.  [DotNetNuke](http://www.cnblogs.com/Mercurius/admin/)&nbsp;DotNetNuke 是微软支持的一套非常优秀的基于asp.net的开源门户网站程序,功能强大,地位类似于PHP中的WordPress\r\n3.  [Umbraco](https://github.com/umbraco/Umbraco-CMS)&nbsp;Umbraco 是一种基于.NET技术的开源的CMS（Content Management System），使用SQL Server或MySQL进行存储数据。Umbraco最大的特色是简单、灵活、易用，不管对于开发者还是网站管理者。 Umbraco还提供了WYSIWYG 编辑器几乎与Microsoft Word完全一样\r\n\r\n## <a name=\"t11\" style=\"padding: 0px; margin: 0px; color: rgb(34, 116, 155);\"></a>工具篇\r\n\r\n1.  [nuget](http://www.cnblogs.com/Mercurius/admin/)&nbsp;vs必备插件第一,项目依赖文件管理.也可以在部门内部架设自己的nuget服务器,用于协作开发中的程序集发布.\r\n2.  [Sandcastle Help File Builder](https://shfb.codeplex.com/)&nbsp;Sandcastle本身是微软出品的一个文档生成工具,用来代替NDoc,SHFB基于SandCastle,提供了更多的选项,工具支持和vs集成,推荐使用\r\n<div style=\"color:gray\"><small>来源：&nbsp;&lt;[http://www.open-open.com/lib/view/open1393838784177.html](http://www.open-open.com/lib/view/open1393838784177.html)<small>&gt;</small></small></div><small><small>&nbsp;</small></small>\r\n\r\n","timestamp":1537195820865},{"name":"05-CSharp调用WinApi方法.md","path":"03-程序语言开发/02-CSharp/05-CSharp调用WinApi方法.md","content":"API函数是构筑Windows应用程序的基石，是Windows编程的必备利器。每一种Windows应用程序开发工具都提供了间接或直接调用了windowsAPI函数的方法，或者是调用Windows API函数的接口，也就是说具备调用动态连接库的能力。Visual C#和其它开发工具一样也能够调用动态链接\r\n库的API函数。本文中笔者就结合实例向大家介绍在Visual C#中如何调用各种返回值的API，该实例就是一个通过API函数调用获取系统信息的\r\n程序。  \r\n首先，在调用API之前，你必须先导入System.Runtime.InteropServices这个名称空间。该名称空间包含了在Visual C#中调用API的一些必要集合，具体的方法如下：  \r\n`using System.Runtime.InteropServices;  `\r\n在导入了名称空间后，我们要声明在程序中所要用到的API函数。我们的程序主要是获取系统的相关信息，所以用到的API函数都是返回系统信息的。先给出在Visual C#中声明API的方法：  \r\n```C#\r\n[DllImport(\"kernel32\")]  \r\npublic static extern void   \r\nGetWindowsDirectory(StringBuilder WinDir,int count);  \r\n```\r\n其中，\"DllImport\"属性用来从不可控代码中调用一个方法，它指定了DLL的位置，该DLL中包含调用的外部方法；\"kernel32\"设定了类库名；public\"指明函数的访问类型为公有的；\"static\"修饰符声明一个静态元素，而该元素属于类型本身而不是指定的对象；\"extern\"表示该方法将在工程外部执行，同时使用DllImport导入的方法必须使用\"extern\"修饰符；最后GetWindowsDirectory函数包含了两个参数，一个为StringBuilder类型的，另一个为int类型的，该方法返回的内容存在于StringBuilder类型的参数中。同时，因为我们在这里使用到了StringBuilder类，所以在程序的开始处，我们还得添加System.Text这个名称空间，方法同上。  \r\n其他几个API函数的声明如下：\r\n```C#\r\n[DllImport(\"kernel32\")]\r\npublic static extern void \r\nGetSystemDirectory(StringBuilder SysDir,int count);\r\n\r\n[DllImport(\"kernel32\")]\r\npublic static extern void GetSystemInfo(ref \r\nCPU_INFO cpuinfo);\r\n\r\n[DllImport(\"kernel32\")]\r\npublic static extern void GlobalMemoryStatus(ref \r\nMEMORY_INFO meminfo);\r\n\r\n[DllImport(\"kernel32\")]\r\npublic static extern void GetSystemTime(ref \r\nSYSTEMTIME_INFO stinfo);\r\n```\r\n以上几个API的作用分别是获取系统路径，获得CPU相关信息，获得内存的相关信息，获得系统时间等.在声明完所有的API函数后，我们发现后三个函数分别用到了CPU_INFO、MEMORY_INFO、SYSTEMTIME_INFO等结构，这些结构并非是.Net内部的，它们从何而来？其实，我们在用到以上API调用时均需用到以上结构，我们将函数调用获得的信息存放在以上的结构体中，最后返回给程序输出。这些结构体比较复杂，但是如果开发者能够熟练运用，那么整个API世界将尽在开发者的掌握之中。以下就是上述结构体的声明：   \r\n```C#\r\n//定义以下各结构\r\n//定义CPU的信息结构\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic \r\nstruct CPU_INFO\r\n{\r\npublic uint dwOemId;\r\npublic uint \r\ndwPageSize;\r\npublic uint lpMinimumApplicationAddr<WBR>ess;\r\npublic uint \r\nlpMaximumApplicationAddr<WBR>ess;\r\npublic uint \r\ndwActiveProcessorMask;\r\npublic uint dwNumberOfProcessors;\r\npublic uint \r\ndwProcessorType;\r\npublic uint dwAllocationGranularity;\r\npublic uint \r\ndwProcessorLevel;\r\npublic uint dwProcessorRevision;\r\n}\r\n\r\n//定义内存的信息结构\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic struct \r\nMEMORY_INFO\r\n{\r\npublic uint dwLength;\r\npublic uint dwMemoryLoad;\r\npublic \r\nuint dwTotalPhys;\r\npublic uint dwAvailPhys;\r\npublic uint \r\ndwTotalPageFile;\r\npublic uint dwAvailPageFile;\r\npublic uint \r\ndwTotalVirtual;\r\npublic uint dwAvailVirtual;\r\n}\r\n\r\n//定义系统时间的信息结构\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic struct \r\nSYSTEMTIME_INFO\r\n{\r\npublic ushort wYear;\r\npublic ushort wMonth;\r\npublic \r\nushort wDayOfWeek;\r\npublic ushort wDay;\r\npublic ushort wHour;\r\npublic \r\nushort wMinute;\r\npublic ushort wSecond;\r\npublic ushort \r\nwMilliseconds;\r\n}\r\n```\r\n结构体定义的主体部分和C++中的没多大差别，具体每个结构体内部成员的定义可参考联机帮助中的SDK文档。同时，我们还发现在每个结\r\n构体定义的上面都有一句用中括号括起来的说明性文字。这些说明都是有关结构体成员的布局的，共有三种选项，分别说明如下：  \r\nLayoutKind.Automatic：为了提高效率允许运行态对类型成员重新排序。  \r\n注意：永远不要使用这个选项来调用不受管辖的动态链接库函数。  \r\nLayoutKind.Explicit：对每个域按照FieldOffset属性对类型成员排序  \r\nLayoutKind.Sequential：对出现在受管辖类型定义地方的不受管辖内存中的类型成员进行排序。  \r\n在上面的程序中，为了方便起见我们都用到了第三种方式。  \r\n所有的API函数以及相关的结构体声明完毕后，我们就运用这些API来实现我们的程序功能――获取系统的相关信息。  \r\n简单的界面布置好后，我们添加一个按钮（\"获取信息\"按钮）的消息处理函数如下：\r\n```C#\r\nprivate void GetInfo_Click(object sender, System.EventArgs e)\r\n{\r\n//调用GetWindowsDirectory和GetSystemDirectory函数分别取得Windows路径和系统路径\r\nconst \r\nint nChars = 128;\r\nStringBuilder Buff = new StringBuilder(nChars);\r\nGetWindowsDirectory(Buff,nChars);\r\nWindowsDirectory.Text \r\n= \r\n\"Windows路径：\"+Buff.ToString();\r\nGetSystemDirectory(Buff,nChars);\r\nSystemDirectory.Text \r\n= \"系统路径：\"+Buff.ToString();\r\n\r\n//调用GetSystemInfo函数获取CPU的相关信息\r\nCPU_INFO CpuInfo;\r\nCpuInfo = new CPU_INFO();\r\nGetSystemInfo(ref CpuInfo);\r\nNumberOfProcessors.Text = \r\n\"本计算机中有\"+CpuInfo.dwNumberOfProcessors.ToString()+\"个CPU\";\r\nProcessorType.Text = \r\n\"CPU的类型为\"+CpuInfo.dwProcessorType.ToString();\r\nProcessorLevel.Text = \r\n\"CPU等级为\"+CpuInfo.dwProcessorLevel.ToString();\r\nOemId.Text = \"CPU的OEM \r\nID为\"+CpuInfo.dwOemId.ToString();\r\nPageSize.Text = \r\n\"CPU中的页面大小为\"+CpuInfo.dwPageSize.ToString();\r\n\r\n//调用GlobalMemoryStatus函数获取内存的相关信息\r\nMEMORY_INFO MemInfo;\r\nMemInfo = new MEMORY_INFO();\r\nGlobalMemoryStatus(ref MemInfo);\r\nMemoryLoad.Text = \r\nMemInfo.dwMemoryLoad.ToString()+\"%的内存正在使用\";\r\nTotalPhys.Text = \r\n\"物理内存共有\"+MemInfo.dwTotalPhys.ToString()+\"字节\";\r\nAvailPhys.Text = \r\n\"可使用的物理内存有\"+MemInfo.dwAvailPhys.ToString()+\"字节\";\r\nTotalPageFile.Text = \r\n\"交换文件总大小为\"+MemInfo.dwTotalPageFile.ToString()+\"字节\";\r\nAvailPageFile.Text = \r\n\"尚可交换文件大小为\"+MemInfo.dwAvailPageFile.ToString()+\"字节\";\r\nTotalVirtual.Text = \r\n\"总虚拟内存有\"+MemInfo.dwTotalVirtual.ToString()+\"字节\";\r\nAvailVirtual.Text = \r\n\"未用虚拟内存有\"+MemInfo.dwAvailVirtual.ToString()+\"字节\";\r\n\r\n//调用GetSystemTime函数获取系统时间信息\r\nSYSTEMTIME_INFO StInfo;\r\nStInfo = new SYSTEMTIME_INFO();\r\nGetSystemTime(ref StInfo);\r\nDate.Text = \r\nStInfo.wYear.ToString()+\"年\"+StInfo.wMonth.ToString()+\"月\"+StInfo.wDay.ToString()+\"日\";\r\nTime.Text = (StInfo.wHour+8).ToString()+\"点\"+StInfo.wMinute.ToString()+\"分\"+StInfo.wSecond.ToString()+\"秒\";\r\n}\r\n```\r\n在上面的消息处理函数中，我们运用了在程序开始处声明的各个API函数获取了系统的相关信息，并最终在界面上以文本标签的方式显示结果。各个文本标签的命名方式可以参见文后附带的源代码，此处暂略。  \r\n结束语：  \r\n通过本文的学习，我相信稍有API使用基础的开发者可以马上触类旁通，很快掌握Visual C#中对API的操作。上面给出的实例仅仅是一个非常简单的示例程序，不过有兴趣的读者可以进一步完善其功能，做出更完美的系统信息检测程序。  ","timestamp":1537195820865},{"name":"06-NET中的各种池.md","path":"03-程序语言开发/02-CSharp/06-NET中的各种池.md","content":"## .NET中的各种池\r\n\r\n在.NET中，常用到的池有四个：字符串拘留池、线程池 、应用程序池、数据库连接池。\r\n\r\n字符串拘留池\r\n\r\n在.NET中字符串是不可变对象，修改字符串变量的值会产生新的对象。为降低性能消耗及减小程序集大小，.NET提供了string interning的功能，直译过来就是字符串拘留。所谓的字符串拘留池(intern pool)其实是一张哈希表，键是字符串字面量，值是托管堆上字符串对象的引用。但若该表过大，则会对性能造成负面影响。在加载程序集时，不同版本的CLR对于是否留用程序集元数据中的字符串字面量（在编译时值已确定）不尽相同。但显式调用string.Intern方法则会将字符串字面量放入池中。\r\n\r\n我们在给string类型变量分配字面量值时，CLR会先到字符串池中看下有没有完全相同的字符串（区分大小写），若有则返回对应的引用，若无，则创建新对象并添加到字符串池中返回引用。但若在运行时（如，使用new关键字）来给字符串变量分配值则不会使用字符串池。\r\n\r\nC#提供了和字符串池相关的两个方法：\r\n```C#\r\n//若str不在字符串池中就创建新字符串对象放到池里并返回引用\r\npublic staticc String Intern(String str);\r\n//若str不在字符串池中不会创建新字符串对象并返回null\r\npublic staticc String IsInterned(String str);\r\n```\r\n示例代码如下：\r\n```C#\r\nvar str = \"abc\";\r\nvar str01 = \"abc\";\r\n//运行时常量\r\nvar str02 = new string(new char[] { \'a\', \'b\', \'c\' });\r\n//编译时常量（可通过反编译器查看编译后的代码）\r\nstring str03 = \"a\" + \"bc\";\r\n\r\nConsole.WriteLine($\"str01==str is {ReferenceEquals(str01, str)}\");\r\nConsole.WriteLine($\"str02==str is {ReferenceEquals(str02, str)}\");\r\nConsole.WriteLine($\"str03==str is {ReferenceEquals(str03, str)}\");\r\n\r\nvar str04 = String.IsInterned(new string(new char[] { \'a\', \'b\' }));\r\nConsole.WriteLine($\"str04 == null is {str04 == null}\");\r\nvar str05 = String.IsInterned(\"abdgj\");\r\nConsole.WriteLine($\"str05={str05}\");\r\n\r\nvar str06 = String.Intern(new string(new char[] { \'a\', \'b\', \'d\', \'e\' }));\r\nConsole.WriteLine($\"str06={str06}\");\r\n```\r\n得到如下结果：  \r\n![](assets/03/02/06-1524905705000.png)\r\n\r\n\r\n线程池\r\n\r\n一个进程中只有一个线程池（MSDN）。另一种说法是，一个CLR中一个线程池（《CLR via C#》），我认同这种说法。一个进程可以加载多个不同版本的CLR，但同一版本的CLR只能有一个。总之，线程不属于应用程序域（AppDomain）。\r\n\r\n若线程池中的线程存在未处理的异常，则会导致当前进程被终止，但有三个例外：\r\n\r\n- ThreadAbortException ，在调用 Abort 方法终止线程时会抛出该异常\r\n\r\n- AppDomainUnloadedException ，在卸载AppDomain时会抛出该异常\r\n\r\n- CLR或宿主进程终止一个线程时\r\n\r\n>在.NET1.0和1.1版本中, CLR会处理掉线程池中未处理的异常。但这样做会破坏应用程序中的状态甚至导致程序挂起，这些不利于调试。\r\n在.NET中，许多场景可以使用线程池。如，异步I/O，回调，注册wait操作，使用委托的异步方法调用及System.Net 中的socket连接。\r\n\r\n但在如下场景中应避免使用线程池中的线程：\r\n\r\n- 需要使用前台线程时\r\n- 线程需要特定优先级时\r\n- 需要执行比较耗时的操作时。因为线程池中的线程数有上限，因此长时间的阻塞可能会影响其它任务的处理\r\n- 当需要放置线程在单线程单元(single-threaded apartment)时。线程池中的线程均在多线程单元(multithreaded apartment)中\r\n- 需要给线程一个稳定的标识或者线程用于特定任务时\r\n-线程池中的线程分为两种：工作线程(Worker)和I/O线程(I/O Completion Port)。这两种线程只是用处不同，并无本质区别。\r\n\r\n线程池中的最小线程数默认为处理器的逻辑核心数。即，在4核计算机上，线程池中工作线程和I/O线程默认的最小数均为4。理论上，线程池中的最大线程数只受可用内存大小限制，但是线程池会限制进程内可用线程的数量。\r\n```C#\r\nThreadPool.GetMinThreads(out var minWorkerThreadCount, out var minIoThreadCount);\r\nConsole.WriteLine($\"minWorkerThreadCount={minWorkerThreadCount},minIoThreadCount={minIoThreadCount}\");\r\nThreadPool.GetMaxThreads(out var maxWorkerThreadCount, out var maxIoThreadCount);\r\nConsole.WriteLine($\"maxWorkerThreadCount={maxWorkerThreadCount},maxIoThreadCount={maxIoThreadCount}\");\r\n```\r\n运算结果如下：\r\n\r\n![](assets/03/02/06-1524905769000.png)\r\n当应用使用线程池中的线程进行工作时，若线程池中没有线程，则会创建新的线程以满足需要，当线程池中的线程数达到设定的最小线程数且无空闲线程时，则会先等待一段时间（最多500ms），500ms过后依然没有空闲线程可供使用则会创建新线程进行工作，但线程池中的线程数不会超过设定的最大线程数。\r\n\r\n当线程池中的线程处于空闲状态一段时间后（不同CLR，这个时间不同），会被销毁。\r\n\r\n当应用负载较低时，线程池中的线程数也有可能小于设定的最小线程数。\r\nmachine.config中线程池配置如下（.NET 配置文件体系参见：ASP.NET Configuration File Hierarchy and Inheritance）：\r\n```C#\r\n<system.web>\r\n     <processModel autoConfig=\"true\"/>\r\n</system.web>\r\n```\r\n配置线程池大小：\r\n```C#\r\n//这种配置方式和处理CPU逻辑核心数无关\r\nThreadPool.SetMaxThreads(1000, 800);\r\nThreadPool.SetMinThreads(20, 20);\r\n```\r\nASP.NET也可通过配置文件进行配置，这种方式是针对每个CPU逻辑核心进行配置：\r\n```C#\r\n<configuration>\r\n <system.web>\r\n    <processModel minWorkerThreads=\"20\" minIoThreads=\"20\" />\r\n </system.web>\r\n</configuration>\r\n```\r\n这样做，在应用启动后会报错：在 machine.config 文件之外使用注册为 allowDefinition=\'MachineOnly\' 的节是错误的。需要修改machine.config文件。\r\n\r\n线程池配置得当对于应用性能提升是有不少帮助的。\r\n\r\n应用程序池\r\n\r\nIIS5中，一台服务器只有一个工作进程，不同应用使用AppDomain进行区分，当工作进程出现问题，所有应用都会受到影响。从IIS6开始引入了应用程序池的概念，应用程序池通过进程来隔离不同的应用程序以防止不同应用之间相互影响。在部署ASP.NET应用时，应用程序池通常有两种托管管道模式可供选择：集成模式和经典模式。\r\n\r\n默认情况下，一个应用程序池有一个工作进程，可以根据实际情况设置多个工作进程，但要考虑资源消耗及本地缓存同步问题。\r\n\r\nIIS6和IIS5中的工作进程隔离均是在服务器级别。在同一台服务器上无法使用不同的工作进程隔离模式。从IIS7开始，工作进程隔离模式是基于应用程序池的，这样就可以在同一台服务器上使用不同的隔离模式。\r\n在应用程序池——高级设置中可以对应用程序池做相关设置，如队列长度，工作进程回收机制等。\r\n\r\n \r\n![](assets/03/02/06-1524905813000.png)\r\n \r\n![](assets/03/02/06-1524905824000.png)\r\n数据库连接池\r\n\r\n和数据库服务器建立连接的过程是比较耗时的，对此，ADO.NET中使用了连接池来进行优化。在.NET中不同的Data Provider对于连接池的处理方式不尽相同。默认情况下，ADO.NET 启用连接池优化，可以通过连接字符串来配置是否启用连接池。\r\n\r\n连接池可以减少和数据库建立连接的次数，连接池中维护着一组活跃的数据库连接。在我们调用IDbConnection的Open方法时，CLR会去连接池中寻找是否有可用的连接，若有则返回该连接而无需与数据库建立新的连接。当我们调用IDbConnection的Close方法时，连接会被连接池回收但不断开与数据库的连接，以备下次使用。连接池中的连接空闲一段时间（约4~8分钟）后或者连接池检测到连接已与服务器断开（需要与服务器通讯才能检测连接是否已断开），那么该连接将会被销毁。\r\n\r\n在第一次打开连接时，ADO.NET会根据连接配置来建立连接池。ADO.NET为每个连接配置创建一个连接池，所以若程序中用到多个不同的连接配置（如，不同的连接字符串），则会有多个连接池。\r\n\r\n若连接池中发生了超时或者其它登录错误，则会抛出异常，那么在接下来的5s内尝试该连接都将失败，这5s钟成为阻塞期。若阻塞期结束后的连接再次失败，则会进入一个新的阻塞期，新的阻塞期时长是上个阻塞期时长的2倍，但最多不超过1分钟。\r\n\r\n如果连接字符串中没有设置MinPoolSize的值，或者将该值设为0，那么当池中没有活动连接时，连接池也会被销毁。但若将MinPoolSize的值设为大于0，那么只有在卸载AppDomain时，连接池才会被销毁。当连接池中发生了较为严重的错误，连接池也会自我清理。\r\n\r\n连接池中最大连接数默认为100，当连接池中连接数已达到上限，且均被占用，那么新的请求会进入队列等到，等待时间超过15s（默认）则会抛出异常。\r\n\r\n数据库连接推荐使用如下写法，这样using语句结束后，连接对象会回到连接池中以便下次请求使用。\r\n```C#\r\nusing (IDbConnection conn = new SqlConnection())\r\n{\r\n\r\n}\r\n```","timestamp":1537195820865},{"name":"01-区块链.md","path":"03-程序语言开发/04-Python/01-区块链.md","content":"","timestamp":1537195820865},{"name":"01-Oracle密码过期，取消密码180天限制.md","path":"03-程序语言开发/05-数据库/01-Oracle密码过期，取消密码180天限制.md","content":"## Oracle密码过期，取消密码180天限制\r\n1. 进入sqlplus模式\r\n```sql\r\nsqlplus / as sysdba;\r\n```\r\n1. 查看用户密码的有效期设置(一般默认的配置文件是DEFAULT)\r\n```sql\r\n　　SELECT * FROM dba_profiles WHERE profile=\'DEFAULT\' AND resource_name=\'PASSWORD_LIFE_TIME\';\r\n```\r\n1. 将密码有效期由默认的180天修改成“无限制”，修改之后不需要重启动数据库，会立即生效\r\n```sql\r\n　　ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;\r\n```\r\n1. 帐户再改一次密码\r\n```sql\r\n　　alter user 用户名 identified by 原密码;\r\n```\r\n1. 使用修改后的用户登录，如果报“ORA-28000:用户已被锁”，解锁\r\n```sql\r\n　　alter user db_user account unlock;\r\n　　commit;\r\n```\r\n\r\n","timestamp":1537195820865},{"name":"01-佛系红包算法.md","path":"03-程序语言开发/06-算法/01-佛系红包算法.md","content":"# 原创佛系红包算法\r\n_来源掘金_  \r\n三年前微信红包爆火的时候，脑补了下背后的分配原理，并用C写了个demo，如今回想觉得当时的解法有一定的趣味性，遂丰富完整了下，用js重写了一遍。  \r\n红包算法需满足的规则如下：\r\n - 所有人抢到金额之和等于红包金额，不能超过，也不能少于；\r\n - 所有人抢到金额的几率相等；\r\n - 每个人抢到的金额均大于0。\r\n我脑补的第一画面就是：_排排坐，分果果_。  \r\n## 于是分配原理如下：  \r\n众人们先按抢红包的顺序依次入座，围成圆环，将金额均分到每个人，然后每人同时将自己手中的金额随机抽出部分给左右临近的2个人，但保证手头至少剩余1单位的金额,完成分配。  \r\n - 由于在总金额的基础上进行交换分配，故满足规则一；  \r\n - 由于在金额均分的基础上再进行同等条件的随机金额交换，故满足规则二；  \r\n - 由于随机分配中保证了至少保留1单位的金额，故满足规则三。  \r\n## 接下来开始实现上述过程\r\n1. 获取分配总额  \r\n由于弱类型语言可变换莫测的入参，在拿到总金额数字的时候必须抖个机灵做下过滤，这里使用了jonschlinkert大神写的is-number函数，用于判断入参是否是数字，否则置它为0；另外，为了规避js中小数运算的精度问题，该算法中只使用整数进行加减，即将小数放到位整数（乘倍数），运算后再缩小回原来倍数（除倍数）。  \r\n```js\r\nclass RandomSplit{\r\n\tconstructor(num){\r\n\t        // 实际总数\r\n\t\tthis.num = this.getNum(num);\r\n\t\t// 放大倍数\r\n\t\ttry{\r\n\t\t\tthis.multiple = this.num.toString().split(\'.\')[1].length;\r\n\t\t}catch(e){\r\n\t\t\tthis.multiple = 0;\r\n\t\t}\r\n\t\t// 用于整数运算的总数\r\n\t\tthis.calcNum = this.num * Math.pow(10, this.multiple);\r\n\t}\r\n\t// 判断是否为number（取用至“is-number”）\r\n\tisNumber(num){\r\n\t\tlet number = +num;\r\n\t\tif((number - number) !== 0){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(number === num){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif(typeof num === \'string\'){\r\n\t\t\tif(number === 0 && num.trim() === \'\'){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t// 获取数字\r\n\tgetNum(num, defaultNum = 0){\r\n\t\treturn this.isNumber(num) ? (+num) : defaultNum;\r\n\t}\r\n}\r\n```\r\n2. 环形入座，将总数按份数均分  \r\n看“环形”二字，仿佛需要使用双向循环链表，为节省代码，这里只用一维数组模拟其效果，在数组首尾做数据衔接即可。在该算法中，所有用于分配交换的数字的原子单位都是整数1，所以均分也需要均分为整数，例如总数15均分为6份，先每份分到2（Math.floor(15/6)===2），还余3（15%6===3），为了使后面用于计算的概率尽可能平均，我们需要把这余下的3个单位均匀洒落到那6份里面，类似过程如下图：  \r\n![](assets/03/06/01-1525328461000.png)    \r\n同理，若想要均分地更加精确，可提供精度的位数，然后将总数按该位数放大，整数均分后每份再按该精度位数缩小。  \r\n于是均分函数如下：// 均分份数， 均分精度， 是否直接返回放大后的整数  \r\n```js\r\naverage(n, precision, isInt){\r\n\tprecision = Math.floor(this.getNum(precision, 0));\r\n\tn = Math.floor(this.getNum(n));\r\n\tlet calcNum = this.calcNum * Math.pow(10, precision<0 ? 0 : precision);\r\n\t// 份数超过放大后的计算总数，即不够分的情况\r\n\tif(n > calcNum){\r\n\t\treturn [];\r\n\t}else{\r\n\t\tlet index = 0;\r\n\t\t// 平均数\r\n\t\tlet avg = Math.floor(calcNum / n);\r\n\t\t// 剩余数\r\n\t\tlet rest = calcNum % n;\r\n\t\t// 剩余数填充间隔\r\n\t\tlet gap = Math.round((n-rest) / rest) + 1;\r\n\t\t// 原始平均数组\r\n\t\tlet result = Array(n).fill(avg);\r\n\t\t// \r\n\t\twhile (rest > 0) {\r\n\t    \t        index = (--rest) * gap;\r\n\t\t\tresult[index>=n ?(n-1) : index]++;\r\n\t\t}\r\n\t\t// 返回放大后的结果数组\r\n\t\tif(isInt){\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\t// 返回处理完符合精度要求的结果数组\r\n\t\treturn result.map((item) => {\r\n\t\t\treturn (item / Math.pow(10, this.multiple + precision));\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n测试效果如下：  \r\n![](assets/03/06/01-1525328497000.png)  \r\n1. 相邻随机交换\r\n得到均分数额后，每个位置先随机出将要给出的数额，该数额大于等于0且小于自己的初始数额，再将该数额随机划分为两份，分别给到相邻的左右位置。  \r\n```js\r\n// 随机划分的份数， 划分精度\r\nsplit(n, precision){\r\n        n = Math.floor(this.getNum(n));\r\n\tprecision = Math.floor(this.getNum(precision, 0));\r\n\t// 均分\r\n\tlet arr = this.average(n, precision, true);\r\n\tlet arrResult = arr.concat();\r\n\tfor (let i = 0; i < arr.length; i++) {\r\n\t        //给出的总额\r\n\t\tlet num = Math.floor(Math.random() * arr[i]);\r\n\t\t// 给左邻的数额\r\n\t\tlet numLeft = Math.floor(Math.random() * num);\r\n\t\t// 给右邻的数额\r\n\t\tlet numRight = num - numLeft;\r\n\t\t// 首尾index处理\r\n\t\tlet iLeft = i===0 ? (arr.length-1) : (i-1);\r\n\t\tlet iRight = i===(arr.length-1) ? 0 : (i+1);\r\n\t\tarrResult[i] -= num;\r\n\t\tarrResult[iLeft] += numLeft;\r\n\t\tarrResult[iRight] += numRight;\r\n\t}\r\n\t// 缩小至原尺度\r\n\treturn arrResult.map((item) => {\r\n\t\treturn (item / Math.pow(10, this.multiple + precision));\r\n\t});\r\n}\r\n``` \r\n测试效果如下：  \r\n![](assets/03/06/01-1525328699000.png)  \r\n## 整体结果测试\r\n使用Echarts绘制随机分配结果，将100数额划分为10份，精度为1，横坐标为顺序位置，纵坐标为分配到的数额：  \r\n![](assets/03/06/01-1525328530000.png)\r\n那每个位置获得数额的概率是否相等呢？下图是随机分配100次的结果，并将每个位置的在这100次分配中所得的平均数用红色标出：  \r\n![](assets/03/06/01-1525328538000.png)  \r\n那分配1000次呢？  \r\n![](assets/03/06/01-1525328549000.png)  \r\n由此可见，随机分配次数越多，每个顺序位置得到的平均数额会稳定在平均分配的数额左右，公平性得到了印证；同时，因为每个位置只能得到相邻两个位置的数额交换，所以分配结果中任意位置的数额不会超过平均数额的3倍（即自己一毛不拔，同时又得到相邻者的倾力相助），这样便可以控制随机分配结果中的最高金额不至于过高。\r\n** 脑洞来了，要是并不是左右相邻进行交换呢？改变交换规则会怎样？ **\r\n - 和除自己外的随机位置的两位进行随机数额交换？从概率上讲，和之前等价...\r\n - 只和自己左右或者右边的位置进行随机数额交换？分配结果依然公平，但最高数额不会超过平均数额的2倍\r\n - 每个位置随机左右一边然后进行随机数额交换？又双叒随机，还是公平的，最高数额还是少于平均数额的3倍（感觉貌似可以替代之前的方案，还能顺便降一倍的线性复杂度，我文章要重写了？！ (°ー°〃)）\r\n - 谁说只能挑2个进行交换？3个4个5个一起来行不行？行... 挑选位置公平的话，分配结果就公平，但是最大数额与交换数量正相关，但越高的数额，能得到的概率会急剧减小。   \r\n\r\n打住打住，再细想下去，我的坑怕是要填不完了 _(:з」∠)_  \r\n## 那这个东西除了可以分红包还能干嘛？\r\n我用它写过一个没有后端数据的进度条，一抖一抖增加长短不一还仿佛真的在帮你加载一样...  \r\n其他...望君发挥想象力  \r\n最后 ( ˙-˙ )  ","timestamp":1537195820865}]